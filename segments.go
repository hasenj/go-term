package term

import (
	"strings"

	"go.hasen.dev/generic"
)

type RawSegment struct {
	Control string
	Text    string
}

const ControlSequenceStart = "\x1B["

var ControlSequenceStartBytes = []byte(ControlSequenceStart)

// FindEndOfControlSequence checks if the text starts with control sequence start and scans to the
// end. If the text does not start with the control sequence start, (0, false) is returned. If the
// control segment does not end properly, (len, false) is returned.
//
// Returns the index indicating the start of the next segment of text, and a bool indicating
// whether a control sequence was successfully scanned
func FindEndOfControlSequence(text string) (int, bool) {
	// range; inclusive
	const ControlEndFirst = 0x40
	const ControlEndLast = 0x7E

	if !strings.HasPrefix(text, ControlSequenceStart) {
		return 0, false
	}
	for i, r := range text {
		if i < 2 {
			continue
		}
		if r >= ControlEndFirst && r <= ControlEndLast {
			// rune length is guaranteed to be one if it's in this range so no need to check
			return i + 1, true
		}
	}
	return len(text), false
}

// Generated by Claude
func SplitRawToSegments(rawText string) (segments []RawSegment) {
	const ControlStart = 0x1B

	nextSegment := func(input string) (rem string) {
		if len(input) == 0 {
			return ""
		}
		control := ""
		text := input
		rem = ""

		cend, _ := FindEndOfControlSequence(input)
		control = input[:cend]
		input = input[cend:]
		next := strings.Index(input, ControlSequenceStart)
		if next == -1 {
			next = len(input)
		}
		text = input[:next]
		rem = input[next:]
		generic.Append(&segments, RawSegment{Control: control, Text: text})
		return rem
	}

	for len(rawText) > 0 {
		rawText = nextSegment(rawText)
	}

	return segments
}
