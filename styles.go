package term

import (
	"strings"
	"unicode"

	"go.hasen.dev/generic"
)

type Color byte
type Attr byte

// builtin attributes supported
const AttrFirst = 1
const AttrLast = 5

const (
	// Arranged as bit flags that map to ansi codes
	Bold Attr = 1 << iota
	Dim
	Italic
	Underline
	Blink

	// Artificial attributes

	DefaultForeground // prevents setting the foreground color
	DefaultBackground // prevents setting the background color

	AttrReset Attr = 0
)

const (
	Black Color = iota
	Red
	Green
	Yellow
	Blue
	Magenta
	Cyan
	White
)

const BrightOffset Color = 8 // add to basic color to make it "bright"

// each channel value can only be from 0-5
func RGB666(r, g, b byte) Color {
	// from Claude
	return Color(16 + (36 * r) + (6 * g) + b)
}

// allows each channel to be specified from 0 to 255 but will be compressed down to 666
func RGBto666(r, g, b byte) Color {
	// mostly from Claude
	r = byte((int(r) * 5) / 255)
	g = byte((int(g) * 5) / 255)
	b = byte((int(b) * 5) / 255)
	return Color(16 + (36 * r) + (6 * g) + b)
}

// g must be 0-23
func Gray24(g byte) Color {
	return Color(232 + g)
}

type Style struct {
	Foreground Color
	Background Color
	Attr       Attr
}

var DefaultStyle = Style{
	Attr: DefaultBackground | DefaultForeground,
}

type StyledSpan struct {
	Text string
	Style
}

type StyledLine struct {
	Spans []StyledSpan
}

type StyledBlock struct {
	Lines []StyledLine
}

type StyledBlockBuilder struct {
	line  StyledLine
	block StyledBlock
}

func JustStyledSpan(style Style, t string) StyledBlock {
	var b StyledBlockBuilder
	b.PushSpan(style, t)
	return b.Done()
}

func (b *StyledBlockBuilder) PushText(t string) {
	generic.Append(&b.line.Spans, StyledSpan{Text: t})
}

func (b *StyledBlockBuilder) PushSpan(style Style, t string) {
	generic.Append(&b.line.Spans, StyledSpan{Style: style, Text: t})
}

func (b *StyledBlockBuilder) PushLine() {
	generic.Append(&b.block.Lines, b.line)
	b.line = StyledLine{}
}

func (b *StyledBlockBuilder) Done() StyledBlock {
	if len(b.line.Spans) > 0 {
		b.PushLine()
	}
	return b.block
}

const ansiReset = "\x1b[0m"

// Print styled block to terminal
func PrintStyledBlock(sb StyledBlock) {
	for _, line := range sb.Lines {
		cmd(ansiReset)
		for _, span := range line.Spans {
			cmd(AnsiCode(span.Style))
			cmd(span.Text)
		}
		cmd(ansiReset)
		cmd("\r\n")
	}
	cmd(ansiReset)
}

func PrintRawText(text string) {
	for _, line := range strings.Split(text, "\n") {
		cmd(line)
		cmd("\r\n")
	}
	cmd(ansiReset)
}

// Generated by Claude
func getRuneWidth(r rune) int {
	// Zero width characters
	if unicode.Is(unicode.Mn, r) || unicode.Is(unicode.Me, r) || unicode.Is(unicode.Cc, r) {
		return 0
	}

	// East Asian characters - wide
	if unicode.Is(unicode.Han, r) || unicode.Is(unicode.Hiragana, r) ||
		unicode.Is(unicode.Katakana, r) || unicode.Is(unicode.Hangul, r) {
		return 2
	}

	return 1
}

type StringTrim struct {
	Trimmed string
	Width   int
	Tail    string
}

func TrimStringToWidth(text string, maxWidth int) (result StringTrim) {
	accumulated := 0
	for i, r := range text {
		w := getRuneWidth(r)
		if w+accumulated > maxWidth {
			result.Width = accumulated
			result.Trimmed = text[:i]
			result.Tail = text[i:]
			return
		}
		accumulated += w
	}
	// does not exceed maxWidth
	result.Trimmed = text
	result.Width = accumulated
	result.Tail = ""
	return
}
